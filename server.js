/*
 * Copyright (C) 2022 Kraft, Royapally, Sarthi, Ramaswamy, Maduru, Harde, Gomes, Bellam, Reddy, Craine, Gupta - All Rights Reserved
 * You may use, distribute and modify this code under the
 * terms of the MIT license that can be found in the LICENSE file or
 * at https://opensource.org/licenses/MIT.
 * You should have received a copy of the MIT license with
 * this file. If not, please write to: develop.nak@gmail.com, or visit https://github.com/SiddarthR56/spark/blob/main/README.md.
 */

/**
 * Logic for setting and starting up the server, setting recognized routes, and
 * setting which server-side socket signals to respond to with server-side functionality.
 *
 * @requires express
 * @requires cors
 * @requires socket.io
 * @requires peer
 * @requires uuid
 * @requires express-rate-limit
 */

/**
 * Express module for starting route-based apps.
 *
 * @const
 */
const express = require('express');

/**
 * The app instance for serving webpage and routing data to any client.
 * Requires no params for instantiation in the context of the server
 * and its default settings.
 *
 * @type {Object}
 * @constructor
 * @fires app#use
 * @fires app#set
 * @fires app#get
 * @fires app#on
 */
const app = express();

/**
 * Module for cross-origin resource sharing; needed so that the protocol default CORS
 * policy can be overridden.
 *
 * @const
 */
const cors = require('cors');

/**
 * The HTTP server module used for starting Spark's server to serve webpage content.
 *
 * @type {Object}
 * @param {Object} [app] Reference to instantiated express app that server module can interface on
 * @const
 * @constructor
 *
 * @listen server#listen
 */
const server = require('http').Server(app);

/**
 * The socket module that allows for peer-to-peer connection support.
 *
 * @type {Object}
 * @const
 * @param {Object} [server] Reference to the HTTP server that will be used to listen for new connections
 * @param {Object} [config] Settings for the socket connection; used for setting CORS origin for connection
 * @constructor
 *
 * @fires io#on
 */
const io = require('socket.io')(server, {
  cors: {
    origin: '*',
  },
});

/**
 * Module for peer.js that allows for express app support for peer-to-peer connections.
 *
 * @const
 */
const ExpressPeerServer = require('peer').ExpressPeerServer;


const peerApp = express();


const peerServer = require('http').createServer(peerApp);


const { v4: uuidV4 } = require('uuid');


const RateLimit = require('express-rate-limit');


const limiter = RateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 20,
});


var roomHostsMap = {};

var roomParticipantsMap = {};


app.set('view engine', 'ejs');

app.use(cors());

app.use(express.static('public'));

app.use(limiter);


peerApp.use(
  '/peerjs',
 
  ExpressPeerServer(peerServer, { debug: true })
);

/**
 * GET / : redirects the user to a room with an ID generated by UUID v4
 *
 * @event app#get
 * @param {string} [path] The path for which the GET will act on
 * @param {function} [callback] The function with request and response pair that runs when the endpoint is hit
 */
app.get('/', (req, res) => {
  res.redirect(`/${uuidV4()}`);
});

/**
 * GET /:room : Parametrized room route that serves back the view/room.ejs file with the given room ID
 *
 * @event app#get
 * @param {string} [path] The path for which the GET will act on, parametrized with :
 * @param {function} [callback] The function with request and response pair that runs when the endpoint is hit
 */
app.get('/:room', (req, res) => {
  res.render('room', { roomId: req.params.room });

  // Initialize the creation of roomParticipantsMap and roomHostsMap
  if (!roomHostsMap[req.params.room]) {
    roomParticipantsMap[req.params.room] = [];
    roomHostsMap[req.params.room] = null;
  }
});


app.get('/:room/close', (req, res) => {
  server.close();
  peerServer.close();
  res.send('Http closed');
});


io.on('connection', (socket) => {
  
  socket.on('join-room', /* istanbul ignore next */ (roomId, userId) => {
   
    // Make the socket join a channel under roomId that the io server will broadcast messages to
    socket.join(roomId);

    // Add anyone who joins the room to the roomParticipantsMap
    roomParticipantsMap[roomId].push(userId);

    // First person to join the room is assumed to be the host
    if (roomHostsMap[roomId] === null) {
      roomHostsMap[roomId] = userId;
    }
    // Broadcast to all existing clients in the room that a user has connected
    socket.to(roomId).emit('user-connected', userId);

  
    socket.on('message', (message) => {
      // Send message to the same room
      io.to(roomId).emit('createMessage', message);
    });

   socket.on('filetransfer',(blob)=>{
io.to(roomId).emit('downloadFile',blob);

   });
    socket.on('muteAllUsers', (userId, roomId) => {
      // check if
      if (roomHostsMap[roomId].includes(userId)) {
        io.to(roomId).emit('muteAll', userId);
      }
    });

    
    socket.on('disconnect', () => {
      socket.to(roomId).emit('user-disconnected', userId);

      // remove participant from the room's map
      const index = roomParticipantsMap[roomId].indexOf(userId);
      roomParticipantsMap[roomId].splice(index, 1);

      // if the user is host, then assign a random person in the participants as the host
      if (roomParticipantsMap[roomId].length > 0 && roomHostsMap[roomId].includes(userId)) {
        const randomElement =
          roomParticipantsMap[roomId][Math.floor(Math.random() * roomParticipantsMap[roomId].length)];
        roomHostsMap[roomId] = randomElement;
      }
    });
  });
});


server.listen(process.env.PORT || 3030);

peerServer.listen(process.env.PEER_PORT || 3001);


module.exports = { app, io };
